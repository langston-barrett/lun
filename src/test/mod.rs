mod warn;

use crate::{
    cache::{self, CacheWriter},
    cli, cmd, file, plan, run,
};

use anyhow::{Context, Result};
use clap::Parser as _;
use expect_test::expect;
use std::{
    num::NonZeroUsize,
    path::{Path, PathBuf},
    process,
};

#[derive(Debug)]
struct TestScenario {
    config: crate::config::Config,
    files: Vec<TestFile>,
    expected_output: Vec<String>,
    run: Option<cli::Run>,
}

#[derive(Clone, Debug)]
struct TestFile {
    path: PathBuf,
    size: usize,
    content: String,
}

impl TestFile {
    fn to_file(&self) -> file::File {
        file::File {
            path: self.path.clone(),
            size: self.size,
            stamp: file::Stamp(file::compute_hash(self.content.as_bytes())),
        }
    }
}

fn process_config_section(scenario: &mut TestScenario, content: &str, path: &Path) -> Result<()> {
    scenario.config = toml::from_str(content.trim())
        .with_context(|| format!("Failed to parse config in test file: {}", path.display()))?;
    Ok(())
}

fn process_output_section(scenario: &mut TestScenario, content: &str) {
    // Parse output: batches are separated by blank lines
    let mut batches = Vec::new();
    let mut current_batch = Vec::new();
    for output_line in content.lines() {
        let trimmed = output_line.trim();
        if trimmed.is_empty() {
            // Blank line separates batches
            if !current_batch.is_empty() {
                batches.push(std::mem::take(&mut current_batch));
            }
        } else {
            current_batch.push(trimmed.to_string());
        }
    }
    // Add remaining batch if any
    if !current_batch.is_empty() {
        batches.push(current_batch);
    }
    // Flatten batches with blank lines between them
    for (i, batch) in batches.iter().enumerate() {
        if i > 0 {
            scenario.expected_output.push(String::new());
        }
        scenario.expected_output.append(&mut batch.clone());
    }
}

fn process_flags_section(scenario: &mut TestScenario, content: &str) {
    let mut args = vec!["run".to_string()];
    for flag_line in content.lines() {
        let trimmed = flag_line.trim();
        if trimmed.is_empty() {
            continue;
        }
        for arg in trimmed.split_whitespace() {
            args.push(arg.to_string());
        }
    }
    let cli = cli::Run::try_parse_from(args.iter().map(|s| s.as_str()))
        .map_err(|e| e.to_string())
        .unwrap();
    scenario.run = Some(cli);
}

fn process_files_section_line(scenario: &mut TestScenario, line: &str) {
    if line.starts_with("- `") && line.contains(":") {
        // Parse file entry like: - `file.py`: 100b
        let file_part = line
            .strip_prefix("- `")
            .and_then(|s| s.split("`: ").next())
            .unwrap_or("");
        let size_part = line
            .split(": ")
            .nth(1)
            .and_then(|s| s.strip_suffix('b'))
            .and_then(|s| s.trim().parse::<usize>().ok())
            .unwrap_or(0);

        // Generate content based on size
        let content = "x".repeat(size_part);
        scenario.files.push(TestFile {
            path: PathBuf::from(file_part),
            size: size_part,
            content,
        });
    }
}

fn process_section_content(
    scenario: &mut TestScenario,
    section: &str,
    content: &str,
    path: &Path,
) -> Result<()> {
    match section {
        "config" => process_config_section(scenario, content, path)?,
        "output" => process_output_section(scenario, content),
        "flags" => process_flags_section(scenario, content),
        _ => {}
    }
    Ok(())
}

// generated by AI ¯\_(ツ)_/¯
fn parse_test_file(path: &Path) -> Result<Vec<TestScenario>> {
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read test file: {}", path.display()))?;

    let mut scenarios = Vec::new();
    let mut current_scenario: Option<TestScenario> = None;
    let mut current_section: Option<String> = None;
    let mut current_content = String::new();
    let mut previous_files: Vec<TestFile> = Vec::new();

    for line in content.lines() {
        if line.starts_with("## Scenario ") {
            if let Some(scenario) = current_scenario.take() {
                // Save files for next scenario
                if !scenario.files.is_empty() {
                    previous_files = scenario.files.clone();
                }
                scenarios.push(scenario);
            }
            // Start new scenario, inherit files from previous if available
            let files = if previous_files.is_empty() {
                Vec::new()
            } else {
                previous_files.clone()
            };
            current_scenario = Some(TestScenario {
                config: crate::config::Config {
                    warns: crate::config::WarnCfg {
                        allow: Vec::new(),
                        warn: Vec::new(),
                        deny: Vec::new(),
                    },
                    tool: Vec::new(),
                    refs: Vec::new(),
                    careful: false,
                    cores: None,
                    mtime: false,
                    ninja: None,
                },
                files,
                expected_output: Vec::new(),
                run: None,
            });
            current_section = None;
            current_content.clear();
        } else if line == "### Config" {
            current_section = Some("config".to_string());
            current_content.clear();
        } else if line == "### Files" {
            current_section = Some("files".to_string());
            current_content.clear();
            // Clear files when Files section starts (new files will be added)
            if let Some(ref mut scenario) = current_scenario {
                scenario.files.clear();
            }
        } else if line == "### Output" {
            current_section = Some("output".to_string());
            current_content.clear();
        } else if line == "### Flags" {
            current_section = Some("flags".to_string());
            current_content.clear();
        } else if line.starts_with("```") {
            if let Some(ref section) = current_section {
                if line == "```toml" || line == "```sh" {
                    // Start of code block
                    current_content.clear();
                } else if line == "```" {
                    // End of code block
                    if let Some(ref mut scenario) = current_scenario {
                        process_section_content(
                            scenario,
                            section.as_str(),
                            &current_content,
                            path,
                        )?;
                    }
                    current_content.clear();
                }
            }
        } else if let Some(ref section) = current_section {
            if section == "files" {
                if let Some(ref mut scenario) = current_scenario {
                    process_files_section_line(scenario, line);
                }
            } else {
                current_content.push_str(line);
                current_content.push('\n');
            }
        }
    }

    if let Some(scenario) = current_scenario {
        scenarios.push(scenario);
    }

    Ok(scenarios)
}

fn command_to_string(cmd: &process::Command) -> String {
    let program = cmd.get_program().to_string_lossy();
    let args: Vec<String> = cmd
        .get_args()
        .map(|arg| arg.to_string_lossy().to_string())
        .collect();
    format!("{} {}", program, args.join(" "))
}

fn jobs_to_string(jobs: &[cmd::Command]) -> Vec<String> {
    let mut result = Vec::new();
    for job in jobs {
        let cmd_str = command_to_string(&job.to_command(run::RunMode::Normal));
        result.push(cmd_str);
    }
    result
}

fn test(path: &'static str) {
    let test_file = PathBuf::from(path);
    let scenarios = parse_test_file(&test_file).unwrap();
    assert!(!scenarios.is_empty());
    let mut cache = cache::HashCache::new(PathBuf::from(".lun"));
    for (i, scenario) in scenarios.iter().enumerate() {
        let default = cli::Run::try_parse_from(["run"])
            .map_err(|e| e.to_string())
            .unwrap();
        let run = scenario.run.as_ref().unwrap_or(&default);

        let mut files = scenario
            .files
            .iter()
            .map(TestFile::to_file)
            .collect::<Vec<_>>();
        run::filter_files(&mut files, &run.only_files, &run.skip_files).unwrap();
        let cores = scenario
            .config
            .cores
            .unwrap_or(const { NonZeroUsize::new(1).unwrap() });
        let tool = scenario
            .config
            .tool
            .iter()
            .cloned()
            .map(|t| t.into_tool(false))
            .collect::<Result<Vec<_>>>()
            .unwrap();
        let run_mode = run::RunMode::from(run);
        let batches = plan::plan(
            &mut cache,
            &tool,
            &files,
            &[],
            cores,
            run_mode,
            run.no_batch,
        )
        .unwrap();
        let out = jobs_to_string(&batches);
        assert_eq!(
            out,
            scenario.expected_output,
            "Scenario {} output mismatch",
            i + 1
        );
        // Simulate executing batches by marking commands as done in the cache
        for cmd in &batches {
            let tool = cmd.tool.clone();
            assert!(tool.config.is_none());
            for file in &cmd.files {
                let key = cache::Key::new(file.stamp, &tool.cmd, None, tool.version);
                cache.done(&key);
            }
        }
    }
}

#[test]
fn parse_test_file_debug() {
    let test_file = PathBuf::from("tests/changing-cli.md");
    let scenarios = parse_test_file(&test_file).unwrap();
    let debug_output = format!("{scenarios:#?}");
    expect![[r#"
        [
            TestScenario {
                config: Config {
                    tool: [
                        Tool {
                            name: None,
                            cmd: "lint --",
                            files: "*.py",
                            granularity: Individual,
                            configs: [],
                            check: None,
                            fix: None,
                            formatter: false,
                        },
                    ],
                    careful: false,
                    cores: None,
                    mtime: false,
                    ninja: None,
                    refs: [],
                    warns: WarnCfg {
                        allow: [],
                        warn: [],
                        deny: [],
                    },
                },
                files: [
                    TestFile {
                        path: "file.py",
                        size: 8,
                        content: "xxxxxxxx",
                    },
                ],
                expected_output: [
                    "lint -- file.py",
                ],
                run: None,
            },
            TestScenario {
                config: Config {
                    tool: [
                        Tool {
                            name: None,
                            cmd: "lint --some-flag --",
                            files: "*.py",
                            granularity: Individual,
                            configs: [],
                            check: None,
                            fix: None,
                            formatter: false,
                        },
                    ],
                    careful: false,
                    cores: None,
                    mtime: false,
                    ninja: None,
                    refs: [],
                    warns: WarnCfg {
                        allow: [],
                        warn: [],
                        deny: [],
                    },
                },
                files: [
                    TestFile {
                        path: "file.py",
                        size: 8,
                        content: "xxxxxxxx",
                    },
                ],
                expected_output: [
                    "lint --some-flag -- file.py",
                ],
                run: None,
            },
        ]"#]]
    .assert_eq(&debug_output);
}

#[test]
fn batch2() {
    test("tests/batch2.md");
}

#[test]
fn batch3() {
    test("tests/batch3.md");
}

#[test]
fn changing_cli() {
    test("tests/changing-cli.md");
}

#[test]
fn format() {
    test("tests/format.md");
}

#[test]
fn no_batch() {
    test("tests/no-batch.md");
}

#[test]
fn only_files() {
    test("tests/only-files.md");
}

#[test]
fn skip_files() {
    test("tests/skip-files.md");
}

#[test]
fn twice() {
    test("tests/twice.md");
}
